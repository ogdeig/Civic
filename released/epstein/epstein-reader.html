<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Released Files ‚Ä¢ Epstein Files | Civic Threat</title>

  <meta name="description" content="Listen to released Epstein court PDFs with text-to-speech, page-by-page controls, a built-in viewer, and on-page highlighting. Adults 21+ only." />
  <meta name="robots" content="index,follow" />

  <meta property="og:title" content="Released Files ‚Ä¢ Epstein Files | Civic Threat" />
  <meta property="og:description" content="Listen to released Epstein court PDFs with text-to-speech, page-by-page controls, a built-in viewer, and on-page highlighting. Adults 21+ only." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://civicthreat.us/released/epstein/epstein-reader" />
  <meta property="og:image" content="https://civicthreat.us/assets/civicthreat-social-1200x630.jpg" />

  <link rel="icon" href="/assets/logo.png" />
  <link rel="stylesheet" href="/styles.css" />

  <style>
    .page-wrap{ max-width: 1120px; margin: 0 auto; padding: 22px 16px 42px; }
    .hero{ padding: 18px 0 10px; }
    .hero h1{ margin: 0 0 6px; font-size: clamp(26px, 4vw, 38px); letter-spacing:.02em; }
    .hero p{ margin: 0; opacity: .9; line-height: 1.5; }

    /* Square containers (match rest of site) */
    .ep-box{ border-radius: 0 !important; }
    .ep-grid{ display:grid; grid-template-columns: 1.15fr .85fr; gap: 16px; margin-top: 16px; }
    @media (max-width: 980px){ .ep-grid{ grid-template-columns: 1fr; } }

    .ep-panel{ border: 1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.25); }
    .ep-panel .pad{ padding: 14px; }

    .ep-label{ font-size: 12px; opacity: .85; margin: 0 0 6px; }
    .ep-row{ display:flex; gap:12px; flex-wrap: wrap; align-items: end; }
    .ep-row > .field{ flex: 1 1 240px; min-width: 220px; }
    .ep-row > .field.small{ flex: 0 0 180px; min-width: 160px; }

    select{
      width: 100%;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: #fff;
      outline: none;
      border-radius: 0;
    }

    .ep-controls{ display:flex; gap:10px; flex-wrap: wrap; margin-top: 12px; }
    .ep-controls .btn{ border-radius: 0 !important; }

    .ep-status{
      margin-top: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      border-radius: 0;
      min-height: 54px;
    }
    .ep-status strong{ display:block; margin-bottom: 4px; }
    .ep-status .big{ font-size: 16px; font-weight: 900; letter-spacing:.02em; }

    .viewer-wrap{ display:flex; flex-direction: column; gap: 10px; }
    .viewer-top{ display:flex; justify-content: space-between; align-items: center; gap: 10px; }
    .viewer-top .meta{ font-size: 12px; opacity: .85; }

    .viewer-shell{
      position: relative;
      width: 100%;
      background: #000;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 0;
      min-height: 420px;
      overflow: hidden;
    }
    .viewer-canvas{
      width: 100%;
      height: auto;
      display:block;
      background:#000;
    }

    /* Text layer overlay for highlighting */
    .textLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      user-select:none;
    }
    .textLayer span{
      position:absolute;
      transform-origin: 0 0;
      color: transparent; /* keep page clean */
      background: transparent;
      white-space: pre;
    }
    .textLayer span.hl{
      background: rgba(255, 235, 59, .45);
      outline: 1px solid rgba(255, 235, 59, .28);
    }

    /* Disclosure */
    .legal{
      margin-top: 12px;
      font-size: 12px;
      opacity: .82;
      line-height: 1.5;
    }

    /* FULL-WIDTH GALLERY SECTION */
    .gallery-section{
      margin-top: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
    }
    .gallery-section .pad{ padding: 14px; }
    .gallery-section h2{
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: .02em;
      font-weight: 1000;
    }
    .gallery-sub{
      margin: 0 0 12px;
      font-size: 12px;
      opacity: .82;
      line-height: 1.5;
      max-width: 92ch;
    }
    .gallery-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 980px){
      .gallery-grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media (max-width: 700px){
      .gallery-grid{ grid-template-columns: 1fr; }
    }
    .g-card{
      margin: 0;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      overflow: hidden;
      cursor: pointer;
    }
    .g-card img{
      width: 100%;
      height: auto;
      display:block;
      background:#000;
    }
    .g-cap{
      padding: 8px 10px;
      font-size: 12px;
      opacity: .85;
      line-height: 1.35;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .g-cap .src{
      margin-top: 6px;
      opacity: .75;
      font-size: 11px;
    }

    /* Viewer pop-out modal (PDF) */
    .viewer-modal{
      position: fixed;
      inset: 0;
      z-index: 9998;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.82);
      padding: 18px;
    }
    .viewer-modal.open{ display:flex; }
    .viewer-modal .card{
      width: min(1080px, 96vw);
      max-height: 92vh;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,10,10,.94);
      border-radius: 0;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
      display:flex;
      flex-direction: column;
    }
    .viewer-modal .head{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .viewer-modal .head strong{ letter-spacing:.02em; }
    .viewer-modal .body{
      padding: 12px;
      overflow: auto;
    }

    /* Image Lightbox */
    .img-modal{
      position: fixed;
      inset: 0;
      z-index: 9997;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.88);
      padding: 16px;
    }
    .img-modal.open{ display:flex; }
    .img-modal .card{
      width: min(1100px, 96vw);
      max-height: 92vh;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,10,10,.94);
      border-radius: 0;
      box-shadow: 0 20px 60px rgba(0,0,0,.65);
      display:flex;
      flex-direction: column;
      overflow: hidden;
    }
    .img-modal .head{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .img-modal .body{
      padding: 12px;
      overflow: auto;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .img-modal img{
      width: 100%;
      height: auto;
      max-width: 980px;
      background:#000;
      border: 1px solid rgba(255,255,255,.12);
    }

    /* 21+ gate */
    .gate{
      position: fixed; inset: 0; z-index: 9999;
      background: rgba(0,0,0,.78);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .gate .card{
      width: min(720px, 100%);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,10,10,.92);
      border-radius: 0;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
    }
    .gate h2{ margin: 0 0 10px; font-size: 22px; }
    .gate p{ margin: 0 0 10px; opacity: .9; line-height: 1.55; }
    .gate .row{ display:flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    .gate label{ display:flex; gap:10px; align-items:center; cursor:pointer; }
    .gate input[type="checkbox"]{ width: 18px; height: 18px; }
    .gate .actions{ display:flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; margin-top: 14px; }
    .gate .btn{ border-radius: 0 !important; }
    .gate .legal{ margin-top: 10px; font-size: 12px; opacity: .8; line-height: 1.45; }

    /* safety net: ensure footer matches header red */
    .site-footer{ background: var(--red) !important; color:#fff; }
    .site-footer a{ color:#fff; }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z03YK1FYXW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Z03YK1FYXW');
  </script>
</head>

<body>
  <!-- Header injected by app.js -->
  <div id="siteHeader"></div>

  <main class="page-wrap">
    <header class="hero">
      <h1>Released Files ‚Ä¢ Epstein Files</h1>
      <p>
        Pick a PDF, choose a voice and speed, then press Play. Use Prev/Next to move one page at a time.
        As it reads, the page highlights the word it‚Äôs speaking.
      </p>
    </header>

    <!-- PLAYER + VIEWER (TOP AREA) -->
    <section class="ep-grid">
      <!-- LEFT: Player -->
      <div class="ep-panel ep-box">
        <div class="pad">
          <div class="ep-row">
            <div class="field">
              <div class="ep-label">Choose a PDF</div>
              <select id="pdfSelect" aria-label="Choose a PDF">
                <option value="">Loading PDFs‚Ä¶</option>
              </select>
            </div>
            <div class="field">
              <div class="ep-label">Voice</div>
              <select id="voiceSelect" aria-label="Choose a voice">
                <option value="">Loading voices‚Ä¶</option>
              </select>
            </div>
            <div class="field small">
              <div class="ep-label">Speed</div>
              <select id="speedSelect" aria-label="Choose reading speed">
                <option value="1">1.0√ó</option>
                <option value="1.25">1.25√ó</option>
                <option value="1.5">1.5√ó</option>
                <option value="2">2.0√ó</option>
              </select>
            </div>
          </div>

          <div class="ep-controls" role="group" aria-label="Playback controls">
            <button class="btn blue" id="btnPlay" type="button">‚ñ∂ Play</button>
            <button class="btn" id="btnPause" type="button">‚è∏ Pause</button>
            <button class="btn danger" id="btnStop" type="button">‚èπ Stop</button>

            <button class="btn" id="btnPrev" type="button">‚Üê Prev Page</button>
            <button class="btn" id="btnNext" type="button">Next Page ‚Üí</button>

            <button class="btn" id="btnMute" type="button">üîá Mute</button>

            <button class="btn" id="btnSkipWord" type="button" title="Skip forward one word (tap repeatedly to skip faster)">‚è© Skip Word</button>

            <button class="btn" id="btnAutoRead" type="button" aria-pressed="false" title="Automatically advance to the next PDF when finished">‚è≠ Auto-Read: Off</button>
            <button class="btn" id="btnLoop" type="button" aria-pressed="false" title="Loops current PDF (unless Auto-Read is on, then loops all PDFs)">üîÅ Loop: Off</button>

            <button class="btn" id="btnSkipFile" type="button" title="Skip to the next PDF file">‚è≠ Skip File</button>
          </div>

          <div class="ep-status ep-box" id="statusBox" aria-live="polite">
            <strong class="big" id="statusTitle">Ready.</strong>
            <div id="statusLine">Select a PDF to begin.</div>
          </div>

          <div class="legal">
            <strong>Disclosure:</strong> This page provides text-to-speech playback and viewing of publicly released documents.
            Content may be explicit, disturbing, or contain allegations. Civic Threat does not endorse wrongdoing and does not make claims about guilt or innocence.
            This tool is provided for accessibility, public-interest review, and discussion. For full context, consult the complete PDF and primary sources.
          </div>
        </div>
      </div>

      <!-- RIGHT: Viewer -->
      <div class="ep-panel ep-box">
        <div class="pad viewer-wrap">
          <div class="viewer-top">
            <div><strong>Viewer</strong></div>
            <div style="display:flex; gap:10px; align-items:center;">
              <div class="meta" id="pageMeta">No PDF loaded.</div>
              <button class="btn" id="btnPopViewer" type="button" title="Pop out a larger viewer">üîç Pop-out</button>
            </div>
          </div>

          <div class="viewer-shell ep-box" id="viewerShell">
            <canvas id="pdfCanvas" class="viewer-canvas" width="1000" height="1400"></canvas>
            <div id="textLayer" class="textLayer" aria-hidden="true"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- FULL-WIDTH IMAGES SECTION -->
    <section class="gallery-section ep-box" aria-label="Released Epstein images">
      <div class="pad">
        <h2>Released Epstein Images</h2>
        <p class="gallery-sub">
          A quick-scroll gallery of publicly released Epstein document images and excerpts. Tap any image to open a larger viewer and flip through the set.
        </p>

        <div id="galleryGrid" class="gallery-grid">
          <div style="opacity:.8;font-size:13px;">Loading images‚Ä¶</div>
        </div>

        <div class="legal" style="margin-top:12px">
          <strong>Image note:</strong> Images are shown for reference alongside the released PDFs. For context, use the PDF reader above and consult the complete file.
        </div>
      </div>
    </section>
  </main>

  <!-- Footer injected by app.js -->
  <div id="siteFooter"></div>

  <!-- PDF pop-out modal -->
  <div class="viewer-modal" id="viewerModal" role="dialog" aria-modal="true" aria-label="Pop-out PDF viewer">
    <div class="card ep-box">
      <div class="head">
        <div>
          <strong>PDF Viewer</strong>
          <span class="meta" id="viewerModalMeta" style="margin-left:10px; opacity:.85; font-size:12px;"></span>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="btnViewerClose" type="button">‚úï Close</button>
        </div>
      </div>
      <div class="body">
        <div class="viewer-shell ep-box" id="viewerShellBig">
          <canvas id="pdfCanvasBig" class="viewer-canvas" width="1600" height="2200"></canvas>
          <div id="textLayerBig" class="textLayer" aria-hidden="true"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Image lightbox -->
  <div class="img-modal" id="imgModal" role="dialog" aria-modal="true" aria-label="Image viewer">
    <div class="card ep-box">
      <div class="head">
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <strong id="imgTitle">Released Epstein Images</strong>
          <span id="imgMeta" style="opacity:.85;font-size:12px"></span>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn" id="imgPrev" type="button">‚Üê Prev</button>
          <button class="btn" id="imgNext" type="button">Next ‚Üí</button>
          <button class="btn" id="imgClose" type="button">‚úï Close</button>
        </div>
      </div>
      <div class="body">
        <img id="imgBig" alt="Released image" />
      </div>
    </div>
  </div>

  <!-- 21+ gate -->
  <div class="gate" id="ageGate" role="dialog" aria-modal="true" aria-labelledby="gateTitle">
    <div class="card ep-box">
      <h2 id="gateTitle">Adults 21+ Only</h2>
      <p>This section may contain sexually explicit descriptions. You must confirm you are twenty-one (21) or older to view and use the reader.</p>
      <div class="row">
        <label for="gateCheck">
          <input id="gateCheck" type="checkbox" />
          <span>I confirm that I am 21 or older.</span>
        </label>
      </div>
      <div class="actions">
        <button class="btn" id="gateLeave" type="button">Leave</button>
        <button class="btn blue" id="gateEnter" type="button" disabled>Continue</button>
      </div>
      <div class="legal">
        By continuing, you agree you are 21+ and understand the content may be explicit.
      </div>
    </div>
  </div>

  <!-- PDF.js -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js" crossorigin="anonymous"></script>
  <script>
    if(window.pdfjsLib){
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    }
  </script>

  <!-- Site header/footer injection (IMPORTANT for Google/footer links) -->
  <script src="/config.js?v=12"></script>
  <script src="/app.js?v=12"></script>

  <!-- Reader + gallery logic -->
  <script>
    (function(){
      "use strict";

      // ---- IMPORTANT PATHS (per your repo structure) ----
      // PDFs are inside: /released/epstein/PDF/
      // PDF list file:  /released/epstein/PDF/pdfs.json
      const PDF_MANIFEST_URL = "./PDF/pdfs.json";

      // Images list file is: /released/epstein/image.json  (as you stated)
      // (If your actual filename is images.json, rename it OR change this constant.)
      const IMAGE_MANIFEST_URL = "./image.json";

      const LS_GATE = "ct_epstein_21_ok";
      const LS_AUTO = "ct_ep_autoRead";
      const LS_LOOP = "ct_ep_loop";
      const LS_VOICE = "ct_ep_voice";
      const LS_SPEED = "ct_ep_speed";
      const LS_PDF   = "ct_ep_pdf";

      const el = (id) => document.getElementById(id);

      const pdfSelect   = el("pdfSelect");
      const voiceSelect = el("voiceSelect");
      const speedSelect = el("speedSelect");

      const btnPlay     = el("btnPlay");
      const btnPause    = el("btnPause");
      const btnStop     = el("btnStop");
      const btnPrev     = el("btnPrev");
      const btnNext     = el("btnNext");
      const btnMute     = el("btnMute");
      const btnSkipWord = el("btnSkipWord");
      const btnAutoRead = el("btnAutoRead");
      const btnLoop     = el("btnLoop");
      const btnSkipFile = el("btnSkipFile");

      const statusTitle = el("statusTitle");
      const statusLine  = el("statusLine");
      const pageMeta    = el("pageMeta");

      const canvas      = el("pdfCanvas");
      const ctx         = canvas && canvas.getContext ? canvas.getContext("2d") : null;
      const textLayer   = el("textLayer");

      const canvasBig   = el("pdfCanvasBig");
      const ctxBig      = canvasBig && canvasBig.getContext ? canvasBig.getContext("2d") : null;
      const textLayerBig= el("textLayerBig");

      const viewerModal = el("viewerModal");
      const btnPopViewer= el("btnPopViewer");
      const btnViewerClose = el("btnViewerClose");
      const viewerModalMeta = el("viewerModalMeta");

      // 21+ gate
      const ageGate  = el("ageGate");
      const gateCheck= el("gateCheck");
      const gateEnter= el("gateEnter");
      const gateLeave= el("gateLeave");

      // Gallery
      const galleryGrid = el("galleryGrid");
      const imgModal = el("imgModal");
      const imgBig = el("imgBig");
      const imgMeta = el("imgMeta");
      const imgPrev = el("imgPrev");
      const imgNext = el("imgNext");
      const imgClose = el("imgClose");

      function setStatus(title, line){
        if (statusTitle) statusTitle.textContent = title || "";
        if (statusLine)  statusLine.textContent = line || "";
      }

      function setBtnState(btn, on, labelOn, labelOff){
        if(!btn) return;
        btn.setAttribute("aria-pressed", on ? "true" : "false");
        btn.textContent = on ? labelOn : labelOff;
      }

      function syncToggleButtons(autoRead, loopOn){
        setBtnState(btnAutoRead, autoRead, "‚è≠ Auto-Read: On", "‚è≠ Auto-Read: Off");
        setBtnState(btnLoop, loopOn, "üîÅ Loop: On", "üîÅ Loop: Off");
      }

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

      function esc(s){
        return String(s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
      }

      // ---------- Age gate ----------
      function showGate(){ if (ageGate) ageGate.style.display = "flex"; }
      function hideGate(){ if (ageGate) ageGate.style.display = "none"; }

      function initGate(){
        const ok = localStorage.getItem(LS_GATE) === "1";
        if (!ok) showGate();
        if (gateEnter) gateEnter.disabled = true;

        if (gateCheck){
          gateCheck.checked = false;
          gateCheck.addEventListener("change", () => {
            if (gateEnter) gateEnter.disabled = !gateCheck.checked;
          });
        }
        if (gateLeave){
          gateLeave.addEventListener("click", () => { location.href = "/"; });
        }
        if (gateEnter){
          gateEnter.addEventListener("click", () => {
            if (!gateCheck || !gateCheck.checked) return;
            localStorage.setItem(LS_GATE, "1");
            hideGate();
          });
        }
      }

      // ---------- Voices ----------
      function populateVoices(){
        if (!("speechSynthesis" in window) || !voiceSelect) return;

        const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
        voiceSelect.innerHTML = "";

        if (!voices.length){
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "Loading voices‚Ä¶";
          voiceSelect.appendChild(opt);
          return;
        }

        voices.sort((a,b) => (a.lang||"").localeCompare(b.lang||"") || (a.name||"").localeCompare(b.name||""));

        const saved = localStorage.getItem(LS_VOICE) || "";
        let bestIdx = -1;

        for (let i=0;i<voices.length;i++){
          const v = voices[i];
          const n = (v.name||"").toLowerCase();
          const lang = (v.lang||"").toLowerCase();
          if (saved && v.name === saved){ bestIdx = i; break; }
          if (bestIdx === -1 && n.includes("google") && lang.startsWith("en-gb") && (n.includes("female") || n.includes("woman"))){
            bestIdx = i;
          }
        }
        if (bestIdx === -1){
          for (let i=0;i<voices.length;i++){
            const v = voices[i];
            const n = (v.name||"").toLowerCase();
            const lang = (v.lang||"").toLowerCase();
            if (lang.startsWith("en-gb") && n.includes("google")) { bestIdx = i; break; }
          }
        }
        if (bestIdx === -1){
          for (let i=0;i<voices.length;i++){
            const v = voices[i];
            if ((v.lang||"").toLowerCase().startsWith("en")) { bestIdx = i; break; }
          }
        }
        if (bestIdx === -1) bestIdx = 0;

        voices.forEach((v, i) => {
          const opt = document.createElement("option");
          opt.value = v.name;
          opt.textContent = `${v.name} (${v.lang})`;
          if (i === bestIdx) opt.selected = true;
          voiceSelect.appendChild(opt);
        });

        localStorage.setItem(LS_VOICE, voiceSelect.value || voices[bestIdx].name);
      }

      if ("speechSynthesis" in window){
        populateVoices();
        speechSynthesis.onvoiceschanged = populateVoices;
      }

      if (speedSelect){
        const saved = localStorage.getItem(LS_SPEED);
        if (saved) speedSelect.value = saved;
        speedSelect.addEventListener("change", () => localStorage.setItem(LS_SPEED, speedSelect.value));
      }
      if (voiceSelect){
        voiceSelect.addEventListener("change", () => localStorage.setItem(LS_VOICE, voiceSelect.value || ""));
      }

      // ---------- Manifests (FIXES YOUR 404s) ----------
      // This now ONLY fetches the correct paths you told me:
      // - ./PDF/pdfs.json
      // - ./image.json
      async function fetchJsonStrict(url){
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
        return r.json();
      }

      function normalizePdfList(data){
        let arr = [];
        if (!data) return arr;
        if (Array.isArray(data)) arr = data;
        else if (Array.isArray(data.pdfs)) arr = data.pdfs;

        const out = [];
        arr.forEach((x, idx) => {
          if (!x) return;
          if (typeof x === "string"){
            out.push({ label: `PDF ${idx+1}`, url: x });
          }else{
            const url = x.url || x.src || x.file || "";
            const label = x.label || x.title || x.name || `PDF ${idx+1}`;
            if (url) out.push({ label, url });
          }
        });
        return out;
      }

      function absolutizeIfNeeded(u){
        // keep relative paths relative to this directory
        return String(u || "").trim();
      }

      let pdfList = [];
      function populatePdfSelect(list){
        if (!pdfSelect) return;

        pdfSelect.innerHTML = "";
        if (!list.length){
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No PDFs found (missing ./PDF/pdfs.json)";
          pdfSelect.appendChild(opt);
          return;
        }

        const saved = localStorage.getItem(LS_PDF) || "";
        let foundSaved = false;

        list.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = absolutizeIfNeeded(p.url);
          opt.textContent = p.label;
          if (saved && opt.value === saved){ opt.selected = true; foundSaved = true; }
          pdfSelect.appendChild(opt);
        });

        if (!foundSaved){
          pdfSelect.selectedIndex = 0;
          localStorage.setItem(LS_PDF, pdfSelect.value || "");
        }

        pdfSelect.addEventListener("change", async () => {
          localStorage.setItem(LS_PDF, pdfSelect.value || "");
          await openSelectedPdf();
        });
      }

      // ---------- PDF.js rendering + text highlight ----------
      let pdfDoc = null;
      let pageNum = 1;
      let numPages = 0;

      let speaking = false;
      let paused = false;
      let muted = false;
      let utter = null;

      let pageText = "";
      let words = [];
      let currentWordIndex = 0;

      function setMeta(){
        if (pageMeta){
          if (!pdfDoc) pageMeta.textContent = "No PDF loaded.";
          else pageMeta.textContent = `Page ${pageNum} of ${numPages}`;
        }
        if (viewerModalMeta){
          viewerModalMeta.textContent = pageMeta ? pageMeta.textContent : "";
        }
      }

      function clearHighlights(){
        if (textLayer) textLayer.querySelectorAll(".hl").forEach(s => s.classList.remove("hl"));
        if (textLayerBig) textLayerBig.querySelectorAll(".hl").forEach(s => s.classList.remove("hl"));
      }

      function tokenizeTextWithPositions(text){
        const out = [];
        const s = String(text || "");
        let i = 0;
        while (i < s.length){
          while (i < s.length && /\s/.test(s[i])) i++;
          if (i >= s.length) break;
          const start = i;
          while (i < s.length && !/\s/.test(s[i])) i++;
          const end = i;
          out.push({ w: s.slice(start,end), start, end });
        }
        return out;
      }

      function findWordByCharRange(start, end){
        for (let i=0;i<words.length;i++){
          const w = words[i];
          if (end <= w.start) continue;
          if (start >= w.end) continue;
          return w;
        }
        return null;
      }

      function highlightWord(i){
        clearHighlights();
        const w = words[i];
        if (!w) return;
        if (w.spanSmall) w.spanSmall.classList.add("hl");
        if (w.spanBig)   w.spanBig.classList.add("hl");
      }

      async function buildWordSpans(page, viewport, layerEl, which){
        if (!layerEl || !window.pdfjsLib || !window.pdfjsLib.Util) return;

        layerEl.innerHTML = "";
        clearHighlights();

        const textContent = await page.getTextContent();

        const parts = [];
        textContent.items.forEach(it => {
          const t = it.str || "";
          if (t) parts.push(t);
        });
        pageText = parts.join(" ").replace(/\s+/g," ").trim();
        const wordList = tokenizeTextWithPositions(pageText);
        words = wordList.map(w => ({...w, spanSmall:null, spanBig:null}));

        const frag = document.createDocumentFragment();
        let pageTextCursor = 0;

        for (const item of textContent.items){
          const strRaw = item.str || "";
          const str = strRaw.replace(/\s+/g," ").trim();
          if (!str) continue;

          let idx = pageText.indexOf(str, pageTextCursor);
          if (idx === -1) idx = pageText.indexOf(str);
          if (idx !== -1) pageTextCursor = idx + str.length;

          const transform = pdfjsLib.Util.transform(viewport.transform, item.transform);
          const x = transform[4];
          const y = transform[5];

          const fontHeight = Math.hypot(transform[2], transform[3]);
          const itemWidth = item.width ? (item.width * viewport.scale) : (str.length * fontHeight * 0.5);

          const wds = str.split(" ").filter(Boolean);
          const totalChars = wds.reduce((a,b)=>a+b.length,0) + Math.max(0, wds.length-1);
          const pxPerChar = totalChars ? (itemWidth / totalChars) : (itemWidth / Math.max(1, str.length));

          let localX = x;
          let localCharCursor = 0;

          for (let wi=0; wi<wds.length; wi++){
            const w = wds[wi];
            const wLen = w.length;

            if (wi > 0){
              localCharCursor += 1;
              localX += pxPerChar;
            }

            const wWidth = pxPerChar * wLen;

            const span = document.createElement("span");
            span.textContent = w;
            span.style.left = `${localX}px`;
            span.style.top  = `${(viewport.height - y)}px`;
            span.style.height = `${fontHeight}px`;
            span.style.width  = `${Math.max(2, wWidth)}px`;
            span.style.fontSize = `${fontHeight}px`;
            span.style.transform = `translateY(-${fontHeight}px)`;
            frag.appendChild(span);

            if (idx !== -1){
              const chunkStart = idx;
              const guessStart = chunkStart + localCharCursor;
              const guessEnd   = guessStart + wLen;

              const best = findWordByCharRange(guessStart, guessEnd);
              if (best){
                if (which === "small") best.spanSmall = span;
                else best.spanBig = span;
              }
            }

            localCharCursor += wLen;
            localX += wWidth;
          }
        }

        layerEl.appendChild(frag);
      }

      async function renderPage(toBigAlso){
        if (!pdfDoc || !ctx || !window.pdfjsLib) return;
        const page = await pdfDoc.getPage(pageNum);

        const container = el("viewerShell");
        const targetW = container ? container.clientWidth : 900;

        const unscaled = page.getViewport({ scale: 1.0 });
        const scale = targetW / unscaled.width;
        const viewport = page.getViewport({ scale });

        canvas.width = Math.floor(viewport.width);
        canvas.height= Math.floor(viewport.height);

        await page.render({ canvasContext: ctx, viewport }).promise;
        await buildWordSpans(page, viewport, textLayer, "small");

        if (toBigAlso && viewerModal && viewerModal.classList.contains("open")){
          await renderBig(page);
        }

        setMeta();
      }

      async function renderBig(page){
        if (!ctxBig || !canvasBig) return;

        const shell = el("viewerShellBig");
        const targetW = shell ? shell.clientWidth : 980;

        const unscaled = page.getViewport({ scale: 1.0 });
        const scale = targetW / unscaled.width;
        const viewport = page.getViewport({ scale });

        canvasBig.width = Math.floor(viewport.width);
        canvasBig.height= Math.floor(viewport.height);

        await page.render({ canvasContext: ctxBig, viewport }).promise;
        await buildWordSpans(page, viewport, textLayerBig, "big");

        setMeta();
      }

      // ---------- Speech ----------
      function getSelectedVoice(){
        const voices = ("speechSynthesis" in window && speechSynthesis.getVoices) ? speechSynthesis.getVoices() : [];
        const name = (voiceSelect && voiceSelect.value) ? voiceSelect.value : (localStorage.getItem(LS_VOICE) || "");
        return voices.find(v => v.name === name) || voices[0] || null;
      }

      function stopSpeech(){
        try{ speechSynthesis.cancel(); }catch(e){}
        utter = null;
        speaking = false;
        paused = false;
      }

      function speakFromWord(startIndex){
        if (!("speechSynthesis" in window)) {
          setStatus("Speech not supported.", "Your browser doesn‚Äôt support text-to-speech.");
          return;
        }
        if (!pageText){
          setStatus("No text found.", "This page has no extractable text to read.");
          return;
        }

        stopSpeech();

        currentWordIndex = clamp(startIndex|0, 0, Math.max(0, words.length-1));
        const startChar = words[currentWordIndex] ? words[currentWordIndex].start : 0;
        const text = pageText.slice(startChar);

        utter = new SpeechSynthesisUtterance(text);
        const v = getSelectedVoice();
        if (v) utter.voice = v;

        const rate = Number(speedSelect && speedSelect.value || 1);
        utter.rate = clamp(rate, 0.5, 2.5);
        utter.volume = muted ? 0 : 1;

        utter.onboundary = function(ev){
          if (!ev) return;
          const pageChar = startChar + (ev.charIndex || 0);

          // binary search word
          let lo = 0, hi = words.length - 1, hit = -1;
          while (lo <= hi){
            const mid = (lo + hi) >> 1;
            const w = words[mid];
            if (pageChar < w.start) hi = mid - 1;
            else if (pageChar >= w.end) lo = mid + 1;
            else { hit = mid; break; }
          }
          if (hit !== -1){
            currentWordIndex = hit;
            highlightWord(hit);
          }
        };

        utter.onend = async function(){
          speaking = false;
          paused = false;
          clearHighlights();

          if (!pdfDoc) return;

          if (pageNum < numPages){
            pageNum++;
            await renderPage(true);
            if (autoRead || loopOn){
              setStatus("Reading‚Ä¶", `Page ${pageNum} of ${numPages}`);
              speakFromWord(0);
            }else{
              setStatus("Finished page.", "Use Next Page or Play to continue.");
            }
            return;
          }

          // End of PDF
          if (autoRead){
            const ok = await advanceToNextPdf(loopOn);
            if (!ok) setStatus("Done.", "Reached the last PDF in the list.");
          }else if (loopOn){
            pageNum = 1;
            await renderPage(true);
            speakFromWord(0);
          }else{
            setStatus("Finished PDF.", "Use Skip File or choose another PDF.");
          }
        };

        utter.onerror = function(){
          speaking = false;
          paused = false;
          setStatus("Audio error.", "Try a different voice, then press Play again.");
        };

        speaking = true;
        paused = false;
        setStatus("Reading‚Ä¶", `Page ${pageNum} of ${numPages}`);
        speechSynthesis.speak(utter);
      }

      function pauseSpeech(){
        if (!("speechSynthesis" in window)) return;
        if (!speaking) return;
        try{ speechSynthesis.pause(); paused = true; setStatus("Paused.", `Page ${pageNum} of ${numPages}`); }catch(e){}
      }
      function resumeSpeech(){
        if (!("speechSynthesis" in window)) return;
        if (!speaking) return;
        try{ speechSynthesis.resume(); paused = false; setStatus("Reading‚Ä¶", `Page ${pageNum} of ${numPages}`); }catch(e){}
      }

      // ---------- PDF open / navigation ----------
      async function openPdf(url){
        if (!window.pdfjsLib) {
          setStatus("PDF engine missing.", "PDF.js failed to load.");
          return;
        }
        stopSpeech();
        clearHighlights();

        setStatus("Loading PDF‚Ä¶", "Please wait.");
        if (pageMeta) pageMeta.textContent = "Loading‚Ä¶";

        const loadingTask = pdfjsLib.getDocument({ url, withCredentials:false });
        pdfDoc = await loadingTask.promise;

        numPages = pdfDoc.numPages || 0;
        pageNum = 1;

        await renderPage(true);
        setStatus("Ready.", "Press Play to start reading.");
      }

      async function openSelectedPdf(){
        const url = (pdfSelect && pdfSelect.value) ? pdfSelect.value : "";
        if (!url){
          setStatus("Ready.", "Select a PDF to begin.");
          return;
        }
        await openPdf(url);
      }

      async function advanceToNextPdf(loopAll){
        if (!pdfList.length || !pdfSelect) return false;
        const cur = pdfSelect.value;
        let idx = pdfList.findIndex(p => absolutizeIfNeeded(p.url) === cur);
        if (idx < 0) idx = 0;

        let nextIdx = idx + 1;
        if (nextIdx >= pdfList.length){
          if (loopAll) nextIdx = 0;
          else return false;
        }

        pdfSelect.value = absolutizeIfNeeded(pdfList[nextIdx].url);
        localStorage.setItem(LS_PDF, pdfSelect.value);
        await openSelectedPdf();
        speakFromWord(0);
        return true;
      }

      // ---------- Controls wiring ----------
      let autoRead = localStorage.getItem(LS_AUTO) === "1";
      let loopOn   = localStorage.getItem(LS_LOOP) === "1";
      syncToggleButtons(autoRead, loopOn);

      if (btnPlay){
        btnPlay.addEventListener("click", async () => {
          if (localStorage.getItem(LS_GATE) !== "1"){
            showGate();
            return;
          }

          if (!pdfDoc){
            await openSelectedPdf();
          }
          if (!pdfDoc){
            setStatus("No PDF selected.", "Pick a PDF first.");
            return;
          }

          if (speaking && paused){ resumeSpeech(); return; }
          if (speaking && !paused){ return; }

          currentWordIndex = 0;
          speakFromWord(0);
        });
      }

      if (btnPause){
        btnPause.addEventListener("click", () => {
          if (!speaking) return;
          if (!paused) pauseSpeech();
          else resumeSpeech();
        });
      }

      if (btnStop){
        btnStop.addEventListener("click", () => {
          stopSpeech();
          clearHighlights();
          currentWordIndex = 0;
          setStatus("Stopped.", "Press Play to start again.");
        });
      }

      if (btnPrev){
        btnPrev.addEventListener("click", async () => {
          if (!pdfDoc) return;
          stopSpeech(); clearHighlights(); currentWordIndex = 0;
          pageNum = clamp(pageNum - 1, 1, numPages);
          await renderPage(true);
          setStatus("Ready.", "Press Play to read this page.");
        });
      }

      if (btnNext){
        btnNext.addEventListener("click", async () => {
          if (!pdfDoc) return;
          stopSpeech(); clearHighlights(); currentWordIndex = 0;
          pageNum = clamp(pageNum + 1, 1, numPages);
          await renderPage(true);
          setStatus("Ready.", "Press Play to read this page.");
        });
      }

      if (btnMute){
        btnMute.addEventListener("click", () => {
          muted = !muted;
          btnMute.textContent = muted ? "üîà Unmute" : "üîá Mute";
          if (utter){
            try{ utter.volume = muted ? 0 : 1; }catch(e){}
          }
        });
      }

      if (btnSkipWord){
        btnSkipWord.addEventListener("click", () => {
          if (!pdfDoc) return;
          const next = clamp((currentWordIndex|0) + 1, 0, Math.max(0, words.length-1));
          currentWordIndex = next;
          highlightWord(next);
          if (speaking) speakFromWord(next);
        });
      }

      if (btnAutoRead){
        btnAutoRead.addEventListener("click", () => {
          autoRead = !autoRead;
          localStorage.setItem(LS_AUTO, autoRead ? "1" : "0");
          syncToggleButtons(autoRead, loopOn);
        });
      }

      if (btnLoop){
        btnLoop.addEventListener("click", () => {
          loopOn = !loopOn;
          localStorage.setItem(LS_LOOP, loopOn ? "1" : "0");
          syncToggleButtons(autoRead, loopOn);
        });
      }

      if (btnSkipFile){
        btnSkipFile.addEventListener("click", async () => {
          if (!pdfList.length){
            setStatus("No PDF list.", "Missing ./PDF/pdfs.json.");
            return;
          }
          stopSpeech(); clearHighlights(); currentWordIndex = 0;
          const ok = await advanceToNextPdf(true);
          if (!ok) setStatus("No next PDF.", "You‚Äôre already on the last one.");
        });
      }

      // ---------- Pop-out viewer ----------
      function openViewer(){
        if (!viewerModal) return;
        viewerModal.classList.add("open");
        if (viewerModalMeta) viewerModalMeta.textContent = pageMeta ? pageMeta.textContent : "";
        if (pdfDoc){
          pdfDoc.getPage(pageNum).then(p => renderBig(p)).catch(()=>{});
        }
      }
      function closeViewer(){
        if (!viewerModal) return;
        viewerModal.classList.remove("open");
      }
      if (btnPopViewer) btnPopViewer.addEventListener("click", openViewer);
      if (btnViewerClose) btnViewerClose.addEventListener("click", closeViewer);
      if (viewerModal){
        viewerModal.addEventListener("click", (e) => { if (e.target === viewerModal) closeViewer(); });
      }

      // ---------- Image lightbox ----------
      let imageList = [];
      let imageIdx = 0;

      function openImgModal(i){
        if (!imgModal || !imgBig) return;
        imageIdx = clamp(i|0, 0, Math.max(0, imageList.length-1));
        const it = imageList[imageIdx];
        if (!it) return;

        imgBig.src = it.src;
        imgBig.alt = it.alt || "Released image";

        if (imgMeta) imgMeta.textContent = `Image ${imageIdx+1} of ${imageList.length}`;
        imgModal.classList.add("open");
      }

      function closeImgModal(){
        if (!imgModal) return;
        imgModal.classList.remove("open");
        if (imgBig) imgBig.src = "";
      }

      function stepImg(dir){
        if (!imageList.length) return;
        const next = (imageIdx + dir + imageList.length) % imageList.length;
        openImgModal(next);
      }

      if (imgPrev) imgPrev.addEventListener("click", () => stepImg(-1));
      if (imgNext) imgNext.addEventListener("click", () => stepImg( 1));
      if (imgClose) imgClose.addEventListener("click", closeImgModal);
      if (imgModal){
        imgModal.addEventListener("click", (e) => { if (e.target === imgModal) closeImgModal(); });
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape"){
          if (viewerModal && viewerModal.classList.contains("open")) closeViewer();
          if (imgModal && imgModal.classList.contains("open")) closeImgModal();
        }
      });

      // ---------- Init ----------
      async function init(){
        initGate();

        // Load PDF list (ONLY the correct path)
        try{
          const data = await fetchJsonStrict(PDF_MANIFEST_URL);
          pdfList = normalizePdfList(data);

          // If the manifest contains relative PDF filenames, it‚Äôs common they‚Äôre relative to the PDF folder.
          // We will NOT auto-prefix anything here (to avoid breaking your existing setup).
          // Just populate exactly what your json provides.
          populatePdfSelect(pdfList);
        }catch(e){
          pdfList = [];
          populatePdfSelect([]);
          setStatus("PDF list missing.", "Could not load ./PDF/pdfs.json (check filename + case).");
        }

        // Restore last selected pdf if it exists
        const savedPdf = localStorage.getItem(LS_PDF);
        if (savedPdf && pdfSelect){
          const opt = Array.from(pdfSelect.options).find(o => o.value === savedPdf);
          if (opt) pdfSelect.value = savedPdf;
        }

        // Preload if gate already accepted
        if (localStorage.getItem(LS_GATE) === "1"){
          if (pdfSelect && pdfSelect.value){
            await openSelectedPdf();
          } else {
            setStatus("Ready.", "Select a PDF to begin.");
          }
        } else {
          setStatus("Locked (21+).", "Confirm age to use the reader.");
        }

        // Gallery images (ONLY the correct path)
        if (galleryGrid){
          try{
            const data = await fetchJsonStrict(IMAGE_MANIFEST_URL);
            const list = Array.isArray(data.images) ? data.images : (Array.isArray(data) ? data : []);
            imageList = list.filter(x => x && x.src).map(x => ({
              src: String(x.src),
              caption: x.caption || "",
              source: x.source || "",
              alt: x.alt || ""
            }));

            galleryGrid.innerHTML = "";
            if(!imageList.length){
              galleryGrid.innerHTML = `<div style="opacity:.8;font-size:13px;">No images available.</div>`;
            }else{
              imageList.forEach((img, idx) => {
                const caption = img.caption ? esc(img.caption) : "Released excerpt image (publicly available).";
                const source = img.source ? esc(img.source) : "Publicly released records";
                const alt = img.alt ? esc(img.alt) : "Released document image.";
                const src = esc(img.src);

                const fig = document.createElement("figure");
                fig.className = "g-card ep-box";
                fig.innerHTML = `
                  <img src="${src}" alt="${alt}" loading="lazy" decoding="async">
                  <figcaption class="g-cap">
                    <div>${caption}</div>
                    <div class="src"><strong>Source:</strong> ${source}</div>
                  </figcaption>
                `;
                fig.addEventListener("click", () => openImgModal(idx));
                galleryGrid.appendChild(fig);
              });
            }
          }catch(e){
            galleryGrid.innerHTML = `<div style="opacity:.85;font-size:13px;line-height:1.5;">Images unavailable right now (could not load <strong>./image.json</strong> ‚Äî check filename + case).</div>`;
          }
        }

        // Re-render on resize
        let resizeTimer = 0;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => { if (pdfDoc) renderPage(true).catch(()=>{}); }, 200);
        }, { passive:true });
      }

      document.addEventListener("DOMContentLoaded", init);
    })();
  </script>
</body>
</html>
