<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Released Files ‚Ä¢ Epstein Files | Civic Threat</title>

  <meta name="description" content="Listen to released Epstein court PDFs with text-to-speech, page-by-page controls, a built-in viewer, and on-page highlighting. Adults 21+ only." />
  <meta name="robots" content="index,follow" />

  <meta property="og:title" content="Released Files ‚Ä¢ Epstein Files | Civic Threat" />
  <meta property="og:description" content="Listen to released Epstein court PDFs with text-to-speech, page-by-page controls, a built-in viewer, and on-page highlighting. Adults 21+ only." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://civicthreat.us/released/epstein/epstein-reader" />
  <meta property="og:image" content="https://civicthreat.us/assets/civicthreat-social-1200x630.jpg" />

  <link rel="icon" href="/assets/logo.png" />
  <link rel="stylesheet" href="/styles.css" />

  <style>
    .page-wrap{ max-width: 1120px; margin: 0 auto; padding: 22px 16px 42px; }
    .hero{ padding: 18px 0 10px; }
    .hero h1{ margin: 0 0 6px; font-size: clamp(26px, 4vw, 38px); letter-spacing:.02em; }
    .hero p{ margin: 0; opacity: .9; line-height: 1.5; }

    /* Square containers (match rest of site) */
    .ep-box{ border-radius: 0 !important; }
    .ep-grid{ display:grid; grid-template-columns: 1.15fr .85fr; gap: 16px; margin-top: 16px; }
    @media (max-width: 980px){ .ep-grid{ grid-template-columns: 1fr; } }

    .ep-panel{ border: 1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.25); }
    .ep-panel .pad{ padding: 14px; }

    .ep-label{ font-size: 12px; opacity: .85; margin: 0 0 6px; }
    .ep-row{ display:flex; gap:12px; flex-wrap: wrap; align-items: end; }
    .ep-row > .field{ flex: 1 1 240px; min-width: 220px; }
    .ep-row > .field.small{ flex: 0 0 180px; min-width: 160px; }

    select{
      width: 100%;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: #fff;
      outline: none;
      border-radius: 0;
    }

    .ep-controls{ display:flex; gap:10px; flex-wrap: wrap; margin-top: 12px; }
    .ep-controls .btn{ border-radius: 0 !important; }

    .ep-status{
      margin-top: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      border-radius: 0;
      min-height: 54px;
    }
    .ep-status strong{ display:block; margin-bottom: 4px; }
    .ep-status .big{ font-size: 16px; font-weight: 900; letter-spacing:.02em; }

    .viewer-wrap{ display:flex; flex-direction: column; gap: 10px; }
    .viewer-top{ display:flex; justify-content: space-between; align-items: center; gap: 10px; }
    .viewer-top .meta{ font-size: 12px; opacity: .85; }

    .viewer-shell{
      position: relative;
      width: 100%;
      background: #000;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 0;
      min-height: 420px;
      overflow: hidden;
    }
    .viewer-canvas{
      width: 100%;
      height: auto;
      display:block;
      background:#000;
    }

    /* Text layer overlay for highlighting */
    .textLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      user-select:none;
    }
    .textLayer span{
      position:absolute;
      transform-origin: 0 0;
      color: transparent; /* keep page clean */
      background: transparent;
      white-space: pre;
    }
    .textLayer span.hl{
      background: rgba(255, 235, 59, .45);
      outline: 1px solid rgba(255, 235, 59, .28);
    }

    /* Disclosure */
    .legal{
      margin-top: 12px;
      font-size: 12px;
      opacity: .82;
      line-height: 1.5;
    }

    /* FULL-WIDTH GALLERY SECTION */
    .gallery-section{
      margin-top: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
    }
    .gallery-section .pad{ padding: 14px; }
    .gallery-section h2{
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: .02em;
      font-weight: 1000;
    }
    .gallery-sub{
      margin: 0 0 12px;
      font-size: 12px;
      opacity: .82;
      line-height: 1.5;
      max-width: 92ch;
    }
    .gallery-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 980px){
      .gallery-grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media (max-width: 700px){
      .gallery-grid{ grid-template-columns: 1fr; }
    }
    .g-card{
      margin: 0;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      overflow: hidden;
      cursor: pointer;
    }
    .g-card img{
      width: 100%;
      height: auto;
      display:block;
      background:#000;
    }
    .g-cap{
      padding: 8px 10px;
      font-size: 12px;
      opacity: .85;
      line-height: 1.35;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .g-cap .src{
      margin-top: 6px;
      opacity: .75;
      font-size: 11px;
    }

    /* Viewer pop-out modal (PDF) */
    .viewer-modal{
      position: fixed;
      inset: 0;
      z-index: 9998;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.82);
      padding: 18px;
    }
    .viewer-modal.open{ display:flex; }
    .viewer-modal .card{
      width: min(1080px, 96vw);
      max-height: 92vh;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,10,10,.94);
      border-radius: 0;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
      display:flex;
      flex-direction: column;
    }
    .viewer-modal .head{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .viewer-modal .head strong{ letter-spacing:.02em; }
    .viewer-modal .body{
      padding: 12px;
      overflow: auto;
    }
    .viewer-modal .viewer-shell{
      border: 1px solid rgba(255,255,255,.12);
      background:#000;
    }

    /* Image Lightbox */
    .img-modal{
      position: fixed;
      inset: 0;
      z-index: 9997;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.88);
      padding: 16px;
    }
    .img-modal.open{ display:flex; }
    .img-modal .card{
      width: min(1100px, 96vw);
      max-height: 92vh;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,10,10,.94);
      border-radius: 0;
      box-shadow: 0 20px 60px rgba(0,0,0,.65);
      display:flex;
      flex-direction: column;
      overflow: hidden;
    }
    .img-modal .head{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .img-modal .body{
      padding: 12px;
      overflow: auto;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .img-modal img{
      width: 100%;
      height: auto;
      max-width: 980px;
      background:#000;
      border: 1px solid rgba(255,255,255,.12);
    }

    /* 21+ gate */
    .gate{
      position: fixed; inset: 0; z-index: 9999;
      background: rgba(0,0,0,.78);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .gate .card{
      width: min(720px, 100%);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,10,10,.92);
      border-radius: 0;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,.6);
    }
    .gate h2{ margin: 0 0 10px; font-size: 22px; }
    .gate p{ margin: 0 0 10px; opacity: .9; line-height: 1.55; }
    .gate .row{ display:flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    .gate label{ display:flex; gap:10px; align-items:center; cursor:pointer; }
    .gate input[type="checkbox"]{ width: 18px; height: 18px; }
    .gate .actions{ display:flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; margin-top: 14px; }
    .gate .btn{ border-radius: 0 !important; }
    .gate .legal{ margin-top: 10px; font-size: 12px; opacity: .8; line-height: 1.45; }

    /* ensure our footer red matches header (app.js also sets red, but this is a safety net) */
    .site-footer{ background: var(--red) !important; color:#fff; }
    .site-footer a{ color:#fff; }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z03YK1FYXW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Z03YK1FYXW');
  </script>
</head>

<body>
  <!-- Header injected by app.js -->
  <div id="siteHeader"></div>

  <main class="page-wrap">
    <header class="hero">
      <h1>Released Files ‚Ä¢ Epstein Files</h1>
      <p>
        Pick a PDF, choose a voice and speed, then press Play. You can Prev/Next page, pop the viewer out bigger,
        and the reader will highlight what it‚Äôs saying (so your eyes can keep up with your ears).
      </p>
    </header>

    <!-- PLAYER + VIEWER (TOP AREA) -->
    <section class="ep-grid">
      <!-- LEFT: Player -->
      <div class="ep-panel ep-box">
        <div class="pad">
          <div class="ep-row">
            <div class="field">
              <div class="ep-label">Choose a PDF</div>
              <select id="pdfSelect" aria-label="Choose a PDF">
                <option value="">Loading PDFs‚Ä¶</option>
              </select>
            </div>
            <div class="field">
              <div class="ep-label">Voice</div>
              <select id="voiceSelect" aria-label="Choose a voice">
                <option value="">Loading voices‚Ä¶</option>
              </select>
            </div>
            <div class="field small">
              <div class="ep-label">Speed</div>
              <select id="speedSelect" aria-label="Choose reading speed">
                <option value="1">1.0√ó</option>
                <option value="1.25">1.25√ó</option>
                <option value="1.5">1.5√ó</option>
                <option value="2">2.0√ó</option>
              </select>
            </div>
          </div>

          <div class="ep-controls" role="group" aria-label="Playback controls">
            <button class="btn blue" id="btnPlay" type="button">‚ñ∂ Play</button>
            <button class="btn" id="btnPause" type="button">‚è∏ Pause</button>
            <!-- STOP MUST BE RED -->
            <button class="btn danger" id="btnStop" type="button">‚èπ Stop</button>

            <button class="btn" id="btnPrev" type="button">‚Üê Prev Page</button>
            <button class="btn" id="btnNext" type="button">Next Page ‚Üí</button>

            <button class="btn" id="btnMute" type="button">üîá Mute</button>

            <!-- NEW: skip one word -->
            <button class="btn" id="btnSkipWord" type="button" title="Skip forward one word (tap repeatedly to skip faster)">‚è© Skip Word</button>

            <!-- loops / file controls -->
            <button class="btn" id="btnAutoRead" type="button" aria-pressed="false" title="Automatically advance to the next PDF when finished">‚è≠ Auto-Read: Off</button>
            <button class="btn" id="btnLoop" type="button" aria-pressed="false" title="Loops current PDF (unless Auto-Read is on, then loops all PDFs)">üîÅ Loop: Off</button>

            <!-- NEW: skip file (especially useful when looping/auto-reading) -->
            <button class="btn" id="btnSkipFile" type="button" title="Skip to the next PDF file">‚è≠ Skip File</button>
          </div>

          <div class="ep-status ep-box" id="statusBox" aria-live="polite">
            <strong class="big" id="statusTitle">Ready.</strong>
            <div id="statusLine">Select a PDF to begin.</div>
          </div>

          <div class="legal">
            <strong>Disclosure:</strong> This page provides text-to-speech playback and viewing of publicly released documents.
            Content may be explicit, disturbing, or contain allegations. Civic Threat does not endorse wrongdoing and does not make claims about guilt or innocence.
            This tool is provided for accessibility, public-interest review, and discussion. For full context, consult the complete PDF and primary sources.
          </div>
        </div>
      </div>

      <!-- RIGHT: Viewer -->
      <div class="ep-panel ep-box">
        <div class="pad viewer-wrap">
          <div class="viewer-top">
            <div><strong>Viewer</strong></div>
            <div style="display:flex; gap:10px; align-items:center;">
              <div class="meta" id="pageMeta">No PDF loaded.</div>
              <button class="btn" id="btnPopViewer" type="button" title="Pop out a larger viewer">üîç Pop-out</button>
            </div>
          </div>

          <div class="viewer-shell ep-box" id="viewerShell">
            <canvas id="pdfCanvas" class="viewer-canvas" width="1000" height="1400"></canvas>
            <div id="textLayer" class="textLayer" aria-hidden="true"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- FULL-WIDTH IMAGES SECTION -->
    <section class="gallery-section ep-box" aria-label="Released Epstein images">
      <div class="pad">
        <h2>Released Epstein Images</h2>
        <p class="gallery-sub">
          A quick-scroll gallery of publicly released Epstein document images and excerpts. Tap any image to open a larger viewer and flip through the set.
          (Because squinting at thumbnails is a hobby nobody asked for.)
        </p>

        <div id="galleryGrid" class="gallery-grid">
          <div style="opacity:.8;font-size:13px;">Loading images‚Ä¶</div>
        </div>

        <div class="legal" style="margin-top:12px">
          <strong>Image note:</strong> Images are shown for reference alongside the released PDFs. For context, use the PDF reader above and consult the complete file.
        </div>
      </div>
    </section>
  </main>

  <!-- Footer injected by app.js (THIS WAS MISSING BEFORE) -->
  <div id="siteFooter"></div>

  <!-- PDF pop-out modal -->
  <div class="viewer-modal" id="viewerModal" role="dialog" aria-modal="true" aria-label="Pop-out PDF viewer">
    <div class="card ep-box">
      <div class="head">
        <div>
          <strong>PDF Viewer</strong>
          <span class="meta" id="viewerModalMeta" style="margin-left:10px; opacity:.85; font-size:12px;"></span>
        </div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="btnViewerClose" type="button">‚úï Close</button>
        </div>
      </div>
      <div class="body">
        <div class="viewer-shell ep-box" id="viewerShellBig">
          <canvas id="pdfCanvasBig" class="viewer-canvas" width="1600" height="2200"></canvas>
          <div id="textLayerBig" class="textLayer" aria-hidden="true"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Image lightbox -->
  <div class="img-modal" id="imgModal" role="dialog" aria-modal="true" aria-label="Image viewer">
    <div class="card ep-box">
      <div class="head">
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <strong id="imgTitle">Image Viewer</strong>
          <span id="imgMeta" style="opacity:.85;font-size:12px"></span>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn" id="imgPrev" type="button">‚Üê Prev</button>
          <button class="btn" id="imgNext" type="button">Next ‚Üí</button>
          <button class="btn" id="imgClose" type="button">‚úï Close</button>
        </div>
      </div>
      <div class="body">
        <img id="imgBig" alt="Released image" />
      </div>
    </div>
  </div>

  <!-- 21+ gate -->
  <div class="gate" id="ageGate" role="dialog" aria-modal="true" aria-labelledby="gateTitle">
    <div class="card ep-box">
      <h2 id="gateTitle">Adults 21+ Only</h2>
      <p>This section may contain sexually explicit descriptions. You must confirm you are twenty-one (21) or older to view and use the reader.</p>
      <div class="row">
        <label for="gateCheck">
          <input id="gateCheck" type="checkbox" />
          <span>I confirm that I am 21 or older.</span>
        </label>
      </div>
      <div class="actions">
        <button class="btn" id="gateLeave" type="button">Leave</button>
        <button class="btn blue" id="gateEnter" type="button" disabled>Continue</button>
      </div>
      <div class="legal">
        By continuing, you agree you are 21+ and understand the content may be explicit.
      </div>
    </div>
  </div>

  <!-- PDF.js -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js" crossorigin="anonymous"></script>
  <script>
    if(window.pdfjsLib){
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    }
  </script>

  <!-- App header/footer (REQUIRED on this page) -->
  <script src="/config.js?v=12"></script>
  <script src="/app.js?v=12"></script>

  <!-- Reader logic (self-contained on this page) -->
  <script>
    (function(){
      "use strict";

      const LS_GATE = "ct_epstein_21_ok";
      const LS_AUTO = "ct_ep_autoRead";
      const LS_LOOP = "ct_ep_loop";
      const LS_VOICE = "ct_ep_voice";
      const LS_SPEED = "ct_ep_speed";
      const LS_PDF   = "ct_ep_pdf";

      const el = (id) => document.getElementById(id);

      const pdfSelect   = el("pdfSelect");
      const voiceSelect = el("voiceSelect");
      const speedSelect = el("speedSelect");

      const btnPlay     = el("btnPlay");
      const btnPause    = el("btnPause");
      const btnStop     = el("btnStop");
      const btnPrev     = el("btnPrev");
      const btnNext     = el("btnNext");
      const btnMute     = el("btnMute");
      const btnSkipWord = el("btnSkipWord");
      const btnAutoRead = el("btnAutoRead");
      const btnLoop     = el("btnLoop");
      const btnSkipFile = el("btnSkipFile");

      const statusTitle = el("statusTitle");
      const statusLine  = el("statusLine");
      const pageMeta    = el("pageMeta");

      const canvas      = el("pdfCanvas");
      const ctx         = canvas.getContext("2d");
      const textLayer   = el("textLayer");

      const canvasBig   = el("pdfCanvasBig");
      const ctxBig      = canvasBig.getContext("2d");
      const textLayerBig= el("textLayerBig");

      const viewerModal = el("viewerModal");
      const btnPopViewer= el("btnPopViewer");
      const btnViewerClose = el("btnViewerClose");
      const viewerModalMeta = el("viewerModalMeta");

      // 21+ gate
      const ageGate  = el("ageGate");
      const gateCheck= el("gateCheck");
      const gateEnter= el("gateEnter");
      const gateLeave= el("gateLeave");

      // State
      let pdfList = [];                 // [{label,url}]
      let pdfDoc = null;
      let pageNum = 1;
      let numPages = 0;

      let autoRead = localStorage.getItem(LS_AUTO) === "1";
      let loopOn   = localStorage.getItem(LS_LOOP) === "1";
      let muted    = false;

      let lastRenderedViewport = null;

      // Speech/highlight state
      let speaking = false;
      let paused = false;
      let utter = null;
      let pageText = "";
      let words = [];                   // [{w, start, end, spanSmall, spanBig}]
      let currentWordIndex = 0;

      function setStatus(title, line){
        if (statusTitle) statusTitle.textContent = title || "";
        if (statusLine)  statusLine.textContent = line || "";
      }

      function setBtnState(btn, on, labelOn, labelOff){
        if(!btn) return;
        btn.setAttribute("aria-pressed", on ? "true" : "false");
        btn.textContent = on ? labelOn : labelOff;
      }

      function syncToggleButtons(){
        setBtnState(btnAutoRead, autoRead, "‚è≠ Auto-Read: On", "‚è≠ Auto-Read: Off");
        setBtnState(btnLoop, loopOn, "üîÅ Loop: On", "üîÅ Loop: Off");
      }
      syncToggleButtons();

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

      function stripHtml(url){
        const s = String(url || "");
        if (!s.startsWith("/")) return s;
        return s.replace(/\.html(\?|#|$)/i, (m) => m.toLowerCase().startsWith(".html") ? m.replace(".html","") : m);
      }

      // ---------- Age gate ----------
      function showGate(){
        if (!ageGate) return;
        ageGate.style.display = "flex";
      }
      function hideGate(){
        if (!ageGate) return;
        ageGate.style.display = "none";
      }
      function initGate(){
        const ok = localStorage.getItem(LS_GATE) === "1";
        if (!ok) showGate();
        if (gateEnter) gateEnter.disabled = true;
        if (gateCheck){
          gateCheck.checked = false;
          gateCheck.addEventListener("change", () => {
            if (gateEnter) gateEnter.disabled = !gateCheck.checked;
          });
        }
        if (gateLeave){
          gateLeave.addEventListener("click", () => {
            // bounce home
            location.href = "/";
          });
        }
        if (gateEnter){
          gateEnter.addEventListener("click", () => {
            if (!gateCheck || !gateCheck.checked) return;
            localStorage.setItem(LS_GATE, "1");
            hideGate();
          });
        }
      }

      // ---------- Voices ----------
      function getPreferredVoiceName(){
        return localStorage.getItem(LS_VOICE) || "";
      }
      function savePreferredVoiceName(name){
        if (name) localStorage.setItem(LS_VOICE, name);
      }

      function populateVoices(){
        const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
        if (!voiceSelect) return;

        voiceSelect.innerHTML = "";
        if (!voices.length){
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No voices available";
          voiceSelect.appendChild(opt);
          return;
        }

        // Sort a little nicer
        voices.sort((a,b) => (a.lang||"").localeCompare(b.lang||"") || (a.name||"").localeCompare(b.name||""));

        const saved = getPreferredVoiceName();

        let bestIdx = -1;
        // Try to default to "Google UK English Female" (or close)
        for (let i=0;i<voices.length;i++){
          const v = voices[i];
          const n = (v.name||"").toLowerCase();
          const lang = (v.lang||"").toLowerCase();
          if (saved && v.name === saved){ bestIdx = i; break; }
          if (bestIdx === -1){
            if (n.includes("google") && lang.startsWith("en-gb") && (n.includes("female") || n.includes("woman"))){
              bestIdx = i;
            }
          }
        }
        if (bestIdx === -1){
          for (let i=0;i<voices.length;i++){
            const v = voices[i];
            const lang = (v.lang||"").toLowerCase();
            const n = (v.name||"").toLowerCase();
            if (lang.startsWith("en-gb") && n.includes("google")) { bestIdx = i; break; }
          }
        }
        if (bestIdx === -1){
          for (let i=0;i<voices.length;i++){
            const v = voices[i];
            const lang = (v.lang||"").toLowerCase();
            if (lang.startsWith("en")) { bestIdx = i; break; }
          }
        }
        if (bestIdx === -1) bestIdx = 0;

        voices.forEach((v, i) => {
          const opt = document.createElement("option");
          opt.value = v.name;
          opt.textContent = `${v.name} (${v.lang})`;
          if (i === bestIdx) opt.selected = true;
          voiceSelect.appendChild(opt);
        });

        savePreferredVoiceName(voiceSelect.value || voices[bestIdx].name);
      }

      // Some browsers load voices async
      if ("speechSynthesis" in window){
        populateVoices();
        speechSynthesis.onvoiceschanged = populateVoices;
      }

      if (speedSelect){
        const saved = localStorage.getItem(LS_SPEED);
        if (saved) speedSelect.value = saved;
        speedSelect.addEventListener("change", () => localStorage.setItem(LS_SPEED, speedSelect.value));
      }
      if (voiceSelect){
        voiceSelect.addEventListener("change", () => savePreferredVoiceName(voiceSelect.value));
      }

      // ---------- PDF list loading ----------
      async function tryFetchJson(url){
        try{
          const r = await fetch(url, { cache: "no-store" });
          if (!r.ok) return null;
          return await r.json();
        }catch(e){
          return null;
        }
      }

      function normalizePdfList(data){
        // Accept:
        // 1) {pdfs:[{label,url}...]}
        // 2) [{label,url}...]
        // 3) ["file1.pdf","file2.pdf"...]
        let arr = [];
        if (!data) return arr;
        if (Array.isArray(data)) arr = data;
        else if (Array.isArray(data.pdfs)) arr = data.pdfs;

        const out = [];
        arr.forEach((x, idx) => {
          if (!x) return;
          if (typeof x === "string"){
            out.push({ label: `PDF ${idx+1}`, url: x });
          }else{
            const url = x.url || x.src || x.file || "";
            const label = x.label || x.title || x.name || `PDF ${idx+1}`;
            if (url) out.push({ label, url });
          }
        });
        return out;
      }

      async function loadPdfManifest(){
        // Common candidates (works regardless of whether you put it in root or /pdfs/)
        const candidates = [
          "./pdfs/pdfs.json",
          "./pdfs.json",
          "./epstein-pdfs.json",
          "./pdf-list.json",
          "./docs.json"
        ];

        for (const u of candidates){
          const data = await tryFetchJson(u);
          const list = normalizePdfList(data);
          if (list.length) return list;
        }
        return [];
      }

      function populatePdfSelect(list){
        if (!pdfSelect) return;
        pdfSelect.innerHTML = "";
        if (!list.length){
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No PDF list found (missing manifest JSON)";
          pdfSelect.appendChild(opt);
          return;
        }

        const saved = localStorage.getItem(LS_PDF) || "";
        let foundSaved = false;

        list.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p.url;
          opt.textContent = p.label;
          if (saved && p.url === saved){ opt.selected = true; foundSaved = true; }
          pdfSelect.appendChild(opt);
        });

        if (!foundSaved){
          pdfSelect.selectedIndex = 0;
          localStorage.setItem(LS_PDF, pdfSelect.value);
        }

        pdfSelect.addEventListener("change", async () => {
          localStorage.setItem(LS_PDF, pdfSelect.value || "");
          await openSelectedPdf();
        });
      }

      // ---------- PDF rendering + text layer ----------
      function clearHighlights(){
        if (textLayer){
          textLayer.querySelectorAll(".hl").forEach(s => s.classList.remove("hl"));
        }
        if (textLayerBig){
          textLayerBig.querySelectorAll(".hl").forEach(s => s.classList.remove("hl"));
        }
      }

      function setMeta(){
        if (pageMeta){
          if (!pdfDoc) pageMeta.textContent = "No PDF loaded.";
          else pageMeta.textContent = `Page ${pageNum} of ${numPages}`;
        }
        if (viewerModalMeta){
          viewerModalMeta.textContent = pageMeta ? pageMeta.textContent : "";
        }
      }

      async function renderPage(toBigAlso){
        if (!pdfDoc) return;
        const page = await pdfDoc.getPage(pageNum);

        // Fit to container width
        const container = document.getElementById("viewerShell");
        const targetW = container ? container.clientWidth : 900;

        const unscaled = page.getViewport({ scale: 1.0 });
        const scale = targetW / unscaled.width;
        const viewport = page.getViewport({ scale });

        lastRenderedViewport = viewport;

        canvas.width = Math.floor(viewport.width);
        canvas.height= Math.floor(viewport.height);

        await page.render({ canvasContext: ctx, viewport }).promise;

        // Text layer for highlight
        await buildWordSpans(page, viewport, textLayer, "small");

        // Big viewer mirrors when open
        if (toBigAlso && viewerModal && viewerModal.classList.contains("open")){
          await renderBig(page);
        }

        setMeta();
      }

      async function renderBig(page){
        const shell = document.getElementById("viewerShellBig");
        const targetW = shell ? shell.clientWidth : 980;

        const unscaled = page.getViewport({ scale: 1.0 });
        const scale = targetW / unscaled.width;
        const viewport = page.getViewport({ scale });

        canvasBig.width = Math.floor(viewport.width);
        canvasBig.height= Math.floor(viewport.height);

        await page.render({ canvasContext: ctxBig, viewport }).promise;
        await buildWordSpans(page, viewport, textLayerBig, "big");

        setMeta();
      }

      function tokenizeTextWithPositions(text){
        // returns [{w,start,end}]
        const out = [];
        const s = String(text || "");
        let i = 0;
        while (i < s.length){
          while (i < s.length && /\s/.test(s[i])) i++;
          if (i >= s.length) break;
          const start = i;
          while (i < s.length && !/\s/.test(s[i])) i++;
          const end = i;
          out.push({ w: s.slice(start,end), start, end });
        }
        return out;
      }

      async function buildWordSpans(page, viewport, layerEl, which){
        if (!layerEl) return;

        layerEl.innerHTML = "";
        clearHighlights();

        const textContent = await page.getTextContent();
        // We'll build approximate word-level spans using each item width split by word count.
        // It‚Äôs not perfect kerning-wise, but it highlights accurately enough for readers.

        const frag = document.createDocumentFragment();

        // Build full page text for speech
        const parts = [];
        textContent.items.forEach(it => {
          const t = it.str || "";
          if (t) parts.push(t);
        });
        pageText = parts.join(" ").replace(/\s+/g," ").trim();
        const wordList = tokenizeTextWithPositions(pageText);

        // Map char ranges to per-word (we‚Äôll fill span refs later)
        words = wordList.map(w => ({...w, spanSmall:null, spanBig:null}));

        // Now create visual spans from PDF items (approx)
        let pageTextCursor = 0;

        for (const item of textContent.items){
          const str = (item.str || "").replace(/\s+/g," ").trim();
          if (!str) continue;

          // Find this chunk within pageText near cursor
          let idx = pageText.indexOf(str, pageTextCursor);
          if (idx === -1){
            idx = pageText.indexOf(str);
          }
          if (idx !== -1) pageTextCursor = idx + str.length;

          const transform = pdfjsLib.Util.transform(viewport.transform, item.transform);
          const x = transform[4];
          const y = transform[5];

          const fontHeight = Math.hypot(transform[2], transform[3]);
          const itemWidth = item.width ? (item.width * viewport.scale) : (str.length * fontHeight * 0.5);

          // Split into words and approximate x ranges
          const wds = str.split(" ").filter(Boolean);
          const totalChars = wds.reduce((a,b)=>a+b.length,0) + Math.max(0, wds.length-1);
          const pxPerChar = totalChars ? (itemWidth / totalChars) : (itemWidth / Math.max(1, str.length));

          let localX = x;
          let localCharCursor = 0;

          for (let wi=0; wi<wds.length; wi++){
            const w = wds[wi];
            const wLen = w.length;

            // account for space before word (except first)
            if (wi > 0){
              localCharCursor += 1;
              localX += pxPerChar;
            }

            const wWidth = pxPerChar * wLen;

            const span = document.createElement("span");
            span.textContent = w; // stays invisible; highlight paints background
            span.style.left = `${localX}px`;
            span.style.top  = `${(viewport.height - y)}px`; // PDF origin bottom-left -> DOM top-left
            span.style.height = `${fontHeight}px`;
            span.style.width  = `${Math.max(2, wWidth)}px`;
            span.style.fontSize = `${fontHeight}px`;
            span.style.transform = `translateY(-${fontHeight}px)`; // align
            frag.appendChild(span);

            // Try to attach this span to the nearest matching word in pageText by char range.
            // We match by searching the next occurrence from a moving pointer.
            if (idx !== -1){
              const chunkStart = idx;
              const guessStart = chunkStart + localCharCursor;
              const guessEnd   = guessStart + wLen;

              const best = findWordByCharRange(guessStart, guessEnd);
              if (best){
                if (which === "small") best.spanSmall = span;
                else best.spanBig = span;
              }
            }

            localCharCursor += wLen;
            localX += wWidth;
          }
        }

        layerEl.appendChild(frag);

        // Ensure any missing spans get a fallback mapping (word->nearest existing)
        // (Not critical; highlights still work even if some words have no box.)
      }

      function findWordByCharRange(start, end){
        // Find a word whose [start,end] overlaps this range
        for (let i=0;i<words.length;i++){
          const w = words[i];
          if (end <= w.start) continue;
          if (start >= w.end) continue;
          return w;
        }
        return null;
      }

      function highlightWord(i){
        clearHighlights();
        const w = words[i];
        if (!w) return;
        if (w.spanSmall) w.spanSmall.classList.add("hl");
        if (w.spanBig)   w.spanBig.classList.add("hl");

        // Auto-scroll big viewer so highlight stays visible
        if (viewerModal && viewerModal.classList.contains("open") && w.spanBig){
          try{
            const body = viewerModal.querySelector(".body");
            const rect = w.spanBig.getBoundingClientRect();
            const bodyRect = body.getBoundingClientRect();
            if (rect.top < bodyRect.top + 60 || rect.bottom > bodyRect.bottom - 60){
              body.scrollTop += (rect.top - bodyRect.top) - 120;
            }
          }catch(e){}
        }
      }

      // ---------- Speech ----------
      function getSelectedVoice(){
        const voices = speechSynthesis.getVoices ? speechSynthesis.getVoices() : [];
        const name = (voiceSelect && voiceSelect.value) ? voiceSelect.value : (localStorage.getItem(LS_VOICE) || "");
        return voices.find(v => v.name === name) || voices[0] || null;
      }

      function stopSpeech(){
        try{ speechSynthesis.cancel(); }catch(e){}
        utter = null;
        speaking = false;
        paused = false;
      }

      function speakFromWord(startIndex){
        if (!("speechSynthesis" in window)) {
          setStatus("Speech not supported.", "Your browser doesn‚Äôt support text-to-speech.");
          return;
        }
        if (!pageText){
          setStatus("No text found.", "This page has no extractable text to read.");
          return;
        }

        stopSpeech();

        currentWordIndex = clamp(startIndex|0, 0, Math.max(0, words.length-1));
        const startChar = words[currentWordIndex] ? words[currentWordIndex].start : 0;
        const text = pageText.slice(startChar);

        utter = new SpeechSynthesisUtterance(text);
        const v = getSelectedVoice();
        if (v) utter.voice = v;

        const rate = Number(speedSelect && speedSelect.value || 1);
        utter.rate = clamp(rate, 0.5, 2.5);

        utter.volume = muted ? 0 : 1;

        // Highlight using boundary events (Chrome/Edge support word boundaries)
        utter.onboundary = function(ev){
          if (!ev) return;

          // ev.charIndex is relative to this utterance text. Convert to page char index.
          const pageChar = startChar + (ev.charIndex || 0);

          // Find the word that contains pageChar
          let lo = 0, hi = words.length - 1, hit = -1;
          while (lo <= hi){
            const mid = (lo + hi) >> 1;
            const w = words[mid];
            if (pageChar < w.start) hi = mid - 1;
            else if (pageChar >= w.end) lo = mid + 1;
            else { hit = mid; break; }
          }
          if (hit !== -1){
            currentWordIndex = hit;
            highlightWord(hit);
          }
        };

        utter.onend = async function(){
          speaking = false;
          paused = false;
          clearHighlights();

          // When page finishes, advance page, then file if needed.
          // If last page: auto-read / loop rules.
          if (!pdfDoc) return;

          if (pageNum < numPages){
            pageNum++;
            await renderPage(true);
            // auto-continue if autoRead OR loopOn (we keep reading pages)
            if (autoRead || loopOn){
              setStatus("Reading‚Ä¶", `Page ${pageNum} of ${numPages}`);
              await startReadingCurrentPage();
            }else{
              setStatus("Finished page.", "Use Next Page or Play to continue.");
            }
            return;
          }

          // End of PDF
          if (autoRead){
            const ok = await advanceToNextPdf(loopOn /*loopAll*/);
            if (!ok){
              setStatus("Done.", "Reached the last PDF in the list.");
            }
          }else if (loopOn){
            // loop same file
            pageNum = 1;
            await renderPage(true);
            await startReadingCurrentPage();
          }else{
            setStatus("Finished PDF.", "Use Skip File or choose another PDF.");
          }
        };

        utter.onerror = function(){
          speaking = false;
          paused = false;
          setStatus("Audio error.", "Try a different voice, then press Play again.");
        };

        speaking = true;
        paused = false;

        setStatus("Reading‚Ä¶", `Page ${pageNum} of ${numPages}`);
        speechSynthesis.speak(utter);
      }

      async function startReadingCurrentPage(){
        // refresh word boxes (in case page just rendered)
        if (!words.length && pageText){
          // nothing; words are built during render
        }
        // start from currentWordIndex (or 0)
        const start = clamp(currentWordIndex|0, 0, Math.max(0, words.length-1));
        speakFromWord(start);
      }

      function pauseSpeech(){
        if (!("speechSynthesis" in window)) return;
        if (!speaking) return;
        try{
          speechSynthesis.pause();
          paused = true;
          setStatus("Paused.", `Page ${pageNum} of ${numPages}`);
        }catch(e){}
      }

      function resumeSpeech(){
        if (!("speechSynthesis" in window)) return;
        if (!speaking) return;
        try{
          speechSynthesis.resume();
          paused = false;
          setStatus("Reading‚Ä¶", `Page ${pageNum} of ${numPages}`);
        }catch(e){}
      }

      // ---------- PDF open / navigation ----------
      async function openPdf(url){
        if (!window.pdfjsLib) {
          setStatus("PDF engine missing.", "PDF.js failed to load.");
          return;
        }
        stopSpeech();
        clearHighlights();

        setStatus("Loading PDF‚Ä¶", "Please wait.");
        pageMeta.textContent = "Loading‚Ä¶";

        const loadingTask = pdfjsLib.getDocument({ url, withCredentials:false });
        pdfDoc = await loadingTask.promise;

        numPages = pdfDoc.numPages || 0;
        pageNum = 1;

        await renderPage(true);
        setStatus("Ready.", "Press Play to start reading.");
      }

      async function openSelectedPdf(){
        const url = (pdfSelect && pdfSelect.value) ? pdfSelect.value : "";
        if (!url){
          setStatus("Ready.", "Select a PDF to begin.");
          return;
        }
        await openPdf(url);
      }

      async function advanceToNextPdf(loopAll){
        if (!pdfList.length || !pdfSelect) return false;
        const cur = pdfSelect.value;
        let idx = pdfList.findIndex(p => p.url === cur);
        if (idx < 0) idx = 0;

        let nextIdx = idx + 1;
        if (nextIdx >= pdfList.length){
          if (loopAll) nextIdx = 0;
          else return false;
        }

        pdfSelect.value = pdfList[nextIdx].url;
        localStorage.setItem(LS_PDF, pdfSelect.value);
        await openSelectedPdf();
        // auto-start
        await startReadingCurrentPage();
        return true;
      }

      // ---------- Controls wiring ----------
      if (btnPlay){
        btnPlay.addEventListener("click", async () => {
          // If gate not accepted, force gate
          if (localStorage.getItem(LS_GATE) !== "1"){
            showGate();
            return;
          }

          if (!pdfDoc){
            await openSelectedPdf();
          }

          if (!pdfDoc){
            setStatus("No PDF selected.", "Pick a PDF first.");
            return;
          }

          // If currently paused, resume; else start from current word.
          if (speaking && paused){
            resumeSpeech();
            return;
          }
          if (speaking && !paused){
            // already speaking: do nothing
            return;
          }

          currentWordIndex = 0;
          await startReadingCurrentPage();
        });
      }

      if (btnPause){
        btnPause.addEventListener("click", () => {
          if (!speaking) return;
          if (!paused) pauseSpeech();
          else resumeSpeech();
        });
      }

      if (btnStop){
        btnStop.addEventListener("click", () => {
          stopSpeech();
          clearHighlights();
          currentWordIndex = 0;
          setStatus("Stopped.", "Press Play to start again.");
        });
      }

      if (btnPrev){
        btnPrev.addEventListener("click", async () => {
          if (!pdfDoc) return;
          stopSpeech();
          clearHighlights();
          currentWordIndex = 0;
          pageNum = clamp(pageNum - 1, 1, numPages);
          await renderPage(true);
          setStatus("Ready.", "Press Play to read this page.");
        });
      }

      if (btnNext){
        btnNext.addEventListener("click", async () => {
          if (!pdfDoc) return;
          stopSpeech();
          clearHighlights();
          currentWordIndex = 0;
          pageNum = clamp(pageNum + 1, 1, numPages);
          await renderPage(true);
          setStatus("Ready.", "Press Play to read this page.");
        });
      }

      if (btnMute){
        btnMute.addEventListener("click", () => {
          muted = !muted;
          btnMute.textContent = muted ? "üîà Unmute" : "üîá Mute";
          if (utter){
            try{ utter.volume = muted ? 0 : 1; }catch(e){}
          }
        });
      }

      if (btnSkipWord){
        btnSkipWord.addEventListener("click", () => {
          if (!pdfDoc) return;
          const next = clamp((currentWordIndex|0) + 1, 0, Math.max(0, words.length-1));
          currentWordIndex = next;
          highlightWord(next);

          // If currently speaking, restart from next word
          if (speaking){
            speakFromWord(next);
          }
        });
      }

      if (btnAutoRead){
        btnAutoRead.addEventListener("click", () => {
          autoRead = !autoRead;
          localStorage.setItem(LS_AUTO, autoRead ? "1" : "0");
          syncToggleButtons();
        });
      }
      if (btnLoop){
        btnLoop.addEventListener("click", () => {
          loopOn = !loopOn;
          localStorage.setItem(LS_LOOP, loopOn ? "1" : "0");
          syncToggleButtons();
        });
      }

      if (btnSkipFile){
        btnSkipFile.addEventListener("click", async () => {
          if (!pdfList.length){
            setStatus("No PDF list.", "Missing PDF manifest JSON.");
            return;
          }
          stopSpeech();
          clearHighlights();
          currentWordIndex = 0;
          const ok = await advanceToNextPdf(true /* allow wrap */);
          if (!ok){
            setStatus("No next PDF.", "You‚Äôre already on the last one.");
          }
        });
      }

      // ---------- Pop-out viewer ----------
      function openViewer(){
        if (!viewerModal) return;
        viewerModal.classList.add("open");
        if (viewerModalMeta) viewerModalMeta.textContent = pageMeta ? pageMeta.textContent : "";
        // render big using current page
        if (pdfDoc){
          pdfDoc.getPage(pageNum).then(p => renderBig(p)).catch(()=>{});
        }
      }
      function closeViewer(){
        if (!viewerModal) return;
        viewerModal.classList.remove("open");
      }

      if (btnPopViewer) btnPopViewer.addEventListener("click", openViewer);
      if (btnViewerClose) btnViewerClose.addEventListener("click", closeViewer);
      if (viewerModal){
        viewerModal.addEventListener("click", (e) => {
          if (e.target === viewerModal) closeViewer();
        });
      }
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape"){
          if (viewerModal && viewerModal.classList.contains("open")) closeViewer();
          if (el("imgModal") && el("imgModal").classList.contains("open")) closeImgModal();
        }
      });

      // Keep big viewer text layer in sync with highlighting
      setInterval(() => {
        if (viewerModal && viewerModal.classList.contains("open")){
          if (viewerModalMeta) viewerModalMeta.textContent = pageMeta ? pageMeta.textContent : "";
        }
      }, 700);

      // ---------- Init ----------
      async function init(){
        initGate();

        // Load PDF manifest
        pdfList = await loadPdfManifest();
        populatePdfSelect(pdfList);

        // Restore last selected pdf if it exists
        const savedPdf = localStorage.getItem(LS_PDF);
        if (savedPdf && pdfSelect){
          const opt = Array.from(pdfSelect.options).find(o => o.value === savedPdf);
          if (opt){
            pdfSelect.value = savedPdf;
          }
        }

        // If gate already accepted and pdf is selected, preload first page (fast UX)
        if (localStorage.getItem(LS_GATE) === "1"){
          if (pdfSelect && pdfSelect.value){
            await openSelectedPdf();
          } else {
            setStatus("Ready.", "Select a PDF to begin.");
          }
        } else {
          setStatus("Locked (21+).", "Confirm age to use the reader.");
        }

        // Re-render on resize to keep canvas fitting container
        let resizeTimer = 0;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            if (pdfDoc) renderPage(true).catch(()=>{});
          }, 200);
        }, { passive:true });
      }

      document.addEventListener("DOMContentLoaded", init);

      // ---------- Gallery / images ----------
      const galleryGrid = el("galleryGrid");
      const imgModal = el("imgModal");
      const imgBig = el("imgBig");
      const imgTitle = el("imgTitle");
      const imgMeta = el("imgMeta");
      const imgPrev = el("imgPrev");
      const imgNext = el("imgNext");
      const imgClose = el("imgClose");

      let imageList = [];
      let imageIdx = 0;

      function esc(s){
        return String(s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
      }

      function openImgModal(i){
        if (!imgModal || !imgBig) return;
        imageIdx = clamp(i|0, 0, Math.max(0, imageList.length-1));
        const it = imageList[imageIdx];
        if (!it) return;

        imgBig.src = it.src;
        imgBig.alt = it.alt || "Released Epstein image";

        if (imgTitle) imgTitle.textContent = "Released Epstein Images";
        if (imgMeta) imgMeta.textContent = `Image ${imageIdx+1} of ${imageList.length}`;

        imgModal.classList.add("open");
      }

      function closeImgModal(){
        if (!imgModal) return;
        imgModal.classList.remove("open");
        if (imgBig) imgBig.src = "";
      }

      function stepImg(dir){
        if (!imageList.length) return;
        const next = (imageIdx + dir + imageList.length) % imageList.length;
        openImgModal(next);
      }

      if (imgPrev) imgPrev.addEventListener("click", () => stepImg(-1));
      if (imgNext) imgNext.addEventListener("click", () => stepImg( 1));
      if (imgClose) imgClose.addEventListener("click", closeImgModal);
      if (imgModal){
        imgModal.addEventListener("click", (e) => { if (e.target === imgModal) closeImgModal(); });
      }

      (function loadImages(){
        if (!galleryGrid) return;

        function card(img, idx){
          const caption = img.caption ? esc(img.caption) : "Released excerpt image (publicly available).";
          const source = img.source ? esc(img.source) : "Publicly released records";
          const alt = img.alt ? esc(img.alt) : "Released Epstein document image.";
          const src = img.src ? String(img.src) : "";

          const fig = document.createElement("figure");
          fig.className = "g-card ep-box";
          fig.innerHTML = `
            <img src="${esc(src)}" alt="${alt}" loading="lazy" decoding="async">
            <figcaption class="g-cap">
              <div>${caption}</div>
              <div class="src"><strong>Source:</strong> ${source}</div>
            </figcaption>
          `;
          fig.addEventListener("click", () => openImgModal(idx));
          return fig;
        }

        // IMPORTANT: your console showed a 404 for /released/epstein/images/images.json
        // This page lives in /released/epstein/, so the correct relative path is:
        // ./images/images.json
        fetch("./images/images.json?v=" + Date.now(), { cache: "no-store" })
          .then(r => { if(!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
          .then(data => {
            const list = Array.isArray(data.images) ? data.images : (Array.isArray(data) ? data : []);
            imageList = list
              .filter(x => x && x.src)
              .map(x => ({
                src: x.src,
                caption: x.caption || "",
                source: x.source || "",
                alt: x.alt || ""
              }));

            galleryGrid.innerHTML = "";
            if(!imageList.length){
              galleryGrid.innerHTML = `<div style="opacity:.8;font-size:13px;">No images available.</div>`;
              return;
            }

            imageList.forEach((img, idx) => galleryGrid.appendChild(card(img, idx)));
          })
          .catch(() => {
            galleryGrid.innerHTML = `<div style="opacity:.85;font-size:13px;line-height:1.5;">Images unavailable right now (missing <strong>./images/images.json</strong> or bad path).</div>`;
          });
      })();

    })();
  </script>
</body>
</html>
